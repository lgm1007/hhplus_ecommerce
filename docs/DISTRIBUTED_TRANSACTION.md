# 시나리오 트랜잭션 범위 분석 및 서비스 확장 대비 보고서
## 개요
만약 현재 시나리오를 MSA 로 확장한다고 가정할 때, 확장에도 안정적인 기능이 동작하도록 현재 트랜잭션 범위를 분석해보고, 적절한 처리 방법을 고려해본다.

## MSA 서비스 분리하기
MSA 구조로 서비스를 확장한다면 다음과 같이 기능 별로 분리할 것으로 고려한다.

1. 주문
2. 결제
3. 상품
4. 잔액 (회원)

## 시나리오 트랜잭션 범위 분석
시나리오에서 핵심 기능인 **주문**과 **결제**의 트랜잭션 범위를 분석했다.

### 주문 트랜잭션

![transaction_range_order](https://github.com/user-attachments/assets/169f74b5-c11c-4928-81dd-90fbf5c0b8de)

주문 기능에서는 이전 Step 12 동시성 제어 과제에서 상품 재고 차감 기능을 이벤트로 분리했다. 즉 주문 기능 중 주문 정보 저장과 장바구니 상품 삭제 기능이 하나의 트랜잭션 범위이며 해당 트랜잭션이 커밋되면 상품 재고 차감 이벤트가 발생, 상품 재고 차감은 별도의 트랜잭션을 가지게 되는 구조이다.

### 결제 트랜잭션

![transaction_range_payment](https://github.com/user-attachments/assets/74aa7e9a-fd23-4ead-90af-5a943e04f0d3)

결제 기능에서는 주문 정보 조회부터 결제 및 주문 상태 업데이트부터 모든 동작을 하나의 트랜잭션 범위에서 처리하고 있다. 이는 기능 내 하나의 동작에서 실패가 발생하면 모든 동작을 롤백 처리하기 위해 설정한 의도이기도 했다.

하지만 서비스가 확장한다고 가정하면 이러한 구조에서는 한계가 존재한다. 어떤 한계가 존재할 지 아래에서 자세히 알아보겠다.

## MSA 구성으로 확장 시 트랜잭션 처리
### 분산 트랜잭션 (Distributed Transaction) 과 현 상태의 트랜잭션 처리 한계
현재 시나리오를 기반으로 모놀로식 아키텍처에서는 단일 DB 환경으로, 사용자가 요청을 보내면 단일 DB에 대한 트랜잭션을 생성하여 상태 확인 및 요청 처리가 수행된다.

(예제는 임의의 주문 요청을 대상으로 그림)

![monolothic-sequence](https://github.com/user-attachments/assets/6b84497d-48bc-4924-98dd-d4f041e8d762)

반면 마이크로서비스 기반 분산된 아키텍처에서는 각 서비스마다 별도의 DB를 구성한다. 따라서 사용자가 요청을 보내면 1개 이상의 서비스가 호출될 수 있고, 1개 이상의 DB에 요청 처리가 수행될 수 있다.

![microservice-sequence](https://github.com/user-attachments/assets/4aacad2a-bf20-4a29-8ef0-1a335e378954)

이처럼 마이크로서비스 기반 아키텍처에서는 각 서비스가 별도의 DB를 가지고 있어 단순하게 트랜잭션을 유지하기 어렵다. 즉 **분산 트랜잭션 환경**으로 구성되어 있다. 따라서 MSA를 설계/구축하기 위해서는 이러한 문제를 포함하여 고려해야 한다.

## 해결 방안
### 2PC (Two-Phase Commit)
2PC 방안은 Prepare 단계와 Commit 단계로 구성하는 분산 트랜잭션 구현 방법이다.

- **Prepare 단계**
    - 관련된 모든 서비스는 Commit 준비하고, Transaction Coodinator에게 트랜잭션을 시작할 준비가 되었음, 즉 Commit할 준비가 되었음을 알린다.
- **Commit 단계**
    - Prepare 단계에서 트랜잭션을 시작할 준비가 되었다면, Coodinator는 Commit을 요청한다. 만약 서비스 하나라도 실패가 발생한다면, Coodinator는 관련된 모든 서비스에 해당 트랜잭션을 롤백하도록 요청한다.

![2pc-sequence](https://github.com/user-attachments/assets/3247fd1b-4b70-4608-95df-44bb9166d206)

2PC 방안을 적용한 예시는 다음과 같다.

1. 사용자가 주문 요청을 보내면 Transaction Coodinator가 트랜잭션을 시작한다.
2. Coodinator가 Order Microservice에게 주문 정보 저장에 대한 Prepare 요청을 보낸다.
3. Coodinator가 Product Microservice에게 재고 차감에 대한 Prepare 요청을 보낸다.
4. Coodinator가 두 서비스에 대해 트랜잭션 처리 준비가 완료되었음을 확인하면 Commit 요청을 보낸다.

2PC 방안은 트랜잭션의 원자성을 보장하는 방식으로, 모든 서비스는 성공하거나 실패한다.

2PC 방안은 분산 트랜잭션 처리를 위한 전통적인 방법이지만, Transaction Coodinator에 의존하여 모든 서비스에 대해 준비 상태를 확인하고, 상태 변경하는 방법이라 성능 측면에서 효율적인 방법은 아니다. 또한 NoSQL 등 일부 구현에도 지원하지 않아서 제약이 있는 방안이다.

### 사가 패턴 (Saga Pattern)
사가 패턴은 각 서비스의 로컬 트랜잭션을 순차적으로 처리하고, 각 로컬 트랜잭션은 DB를 업데이트한 후 다음 로컬 트랜잭션을 트리거하는 메시지를 게시한다. 트랜잭션의 결과에 따라 롤백이 필요한 경우 보상 트랜잭션을 진행한다.

**보상 트랜잭션**은 서비스에서 트랜잭션 처리에 실패할 경우 그 서비스의 앞선 다른 서비스의 트랜잭션 처리를 되돌리는 트랜잭션이다.

사가 패턴은 크게 2가지로 구분할 수 있다.

#### 코레오그래피 기반 사가 (Choreography-based Saga)
각 로컬 트랜잭션이 다른 서비스의 로컬 트랜잭션을 이벤트 트리거하는 방식이다. 중앙 집중된 지점 없이 이벤트를 교환하며, 모든 서비스가 메시지 브로커를 통해 이벤트를 발행/소비한다.

다음은 현재 시나리오의 주문 기능을 코레오그래피 기반의 사가 패턴을 구현한 예시이다.

![choreography-based-saga](https://github.com/user-attachments/assets/040862f5-ace6-4d67-9148-82b5f02be3e4)

1. 주문 요청하면 Order 서비스는 주문 저장 트랜잭션을 처리하고 결과를 Product 서비스에게 이벤트로 전달한다.
2. 트랜잭션 성공, 실패 응답이 큐 (channel)에 들어간다.
3. Product 서비스의 이벤트 핸들러가 발생한 주문 요청에 대해 재고 차감 시도한다.
4. 재고 차감 시도한 후 결과에 대해 이벤트를 발생시킨다.
5. Order 서비스는 결과에 따라 실패한 경우에는 보상 트랜잭션, 문제 없는 경우에는 다음 프로세스를 진행한다.

코레오그래피 기반 사가 패턴의 **장점**은 추가 서비스 구현이 필요하지 않아 서비스가 많지 않은 간단한 플로우에 적합하다.

**단점**은 어떤 서비스가 어떤 이벤트를 수신 대기하는지 추적이 어렵다는 점과, 새로운 서비스 추가가 필요한 경우 워크플로우가 복잡해질 수 있다는 점이 있다. 그리고 각 서비스 간 이벤트를 전달해주는 구조 상 순환 종속성 문제가 발생할 수 있다.

#### 오케스트레이션 기반 사가 (Orchestration-based Saga)
분산 트랜잭션을 책임지는 별도의 중계자가 중앙 집중식 컨트롤러 역할을 하고 각 서비스에 실행할 트랜잭션을 알려주는 방식이다. 중계자는 사가 인스턴스를 발급하여 요청 실행, 각 서비스 상태 확인, 실패에 대한 복구를 처리한다.

다음은 현재 시나리오의 주문 기능을 오케스트레이션 기반의 사가 패턴을 구현한 예시이다.

![orchestration-saga](https://github.com/user-attachments/assets/b5c94e07-b66c-4d95-824f-221faf540c58)

1. 주문 요청하면 Order 서비스에서 요청을 수신하고, 중계자가 주문 로직인 주문 저장 동작을 수행한다.
2. 재고 차감 명령 이벤트를 발생시킨다.
3. Product 서비스가 재고 차감을 시도한다.
4. 재고 차감을 시도한 결과를 이벤트로 응답한다.
5. 주문 로직 트랜잭션이 끝나면 중계자를 종료하여 전체 트랜잭션 처리를 종료한다.

오케스트레이션 기반 사가 패턴의 **장점**은 시간이 지나면서 새로운 서비스가 추가되는 복잡한 워크플로우에 적합하다. 또한 중계자는 일방적으로 서비스에 의존하기 때문에 순환 종속성 문제가 발생되지 않는다.

**단점**은 중계자가 전체 워크플로우를 관리하기 때문에 이 부분이 실패 지점이 될 수 있다.

오케스트레이션 기반 사가 패턴은 대표적으로 Axon 프레임워크를 통해 구현할 수 있다.
사가 패턴은 트랜잭션의 **격리성 (Isolation)**을 보장하지 않는다는 특징이 있다. 따라서 이러한 문제점을 보완하기 위한 설계가 필요하다.
